use std::path::PathBuf;
use pest::Parser;
use pest_derive::Parser;
use std::collections::HashMap;
use std::fs;
use color_eyre::eyre::WrapErr;
use pest::iterators::Pair;

#[derive(Parser)]
#[grammar = "olc.pest"]
/// Parser for a `BLHA2` contract file. Only the table of subprocesses is kept, the initialization
/// fields are discarded.
///
/// The grammar used to parse the contract file is derived from contract files generated by
/// GoSam and Openloops2.
pub struct OLCParser;

impl OLCParser {
    /// Same as [OLCParser::subprocess_table_from_string], but the content is read from `file`.
    pub fn subprocess_table_from_file(file: &PathBuf) -> eyre::Result<HashMap<(Vec<i32>, Vec<i32>), i32>> {
        let file_content = fs::read_to_string(file)
            .wrap_err_with(|| format!("Failed to read contract file {:#?}", file))?;
        let parsed_file = OLCParser::parse(Rule::file, &file_content)?.next().unwrap();
        return Self::translate_rules(parsed_file);

    }
    /// Reads a `BLHA2` contract file from the `String` `content` and returns a hash map containing
    /// all subprocesses defined in the contract file. The key is a tuple of vectors
    /// `(Vec<i32>, Vec<i32>) containing a list of the incoming PDG codes in the first entry and a
    /// list of outgoing PDG codes in the second component. The value assigned to the key is the ID
    /// assigned to the subprocess by the OLP.
    ///
    /// # Example
    /// ```rust
    /// use BLHACompare::OLCParser::OLCParser;
    /// let table = OLCParser::subprocess_table_from_string(&String::from(r"AmplitudeType Tree | OK
    /// -2 21 -> 25 25 -2 -3 3 | 1 16")).unwrap();
    /// assert_eq!(*table.get(&(vec![-2, 21], vec![25, 25, -2, -3, 3])).unwrap(), 16);
    /// ```
    pub fn subprocess_table_from_string(content: &String) -> eyre::Result<HashMap<(Vec<i32>, Vec<i32>), i32>> {
        let parsed_string = OLCParser::parse(Rule::file, content)?.next().unwrap();
        return Self::translate_rules(parsed_string);
    }

    fn translate_rules(parsed_content: Pair<Rule>) -> eyre::Result<HashMap<(Vec<i32>, Vec<i32>), i32>>{
        let mut sp_table = HashMap::<(Vec<i32>, Vec<i32>), i32>::new();
        for sp_rule in parsed_content.into_inner() {
            match sp_rule.as_rule() {
                Rule::subprocess => {
                    let mut inner_rules = sp_rule.into_inner();
                    let mut initial_particles = Vec::<i32>::new();
                    let mut final_particles = Vec::<i32>::new();
                    let mut sp_spec = inner_rules.next().unwrap().into_inner();
                    for initial_pdg in sp_spec.next().unwrap().into_inner() {
                        initial_particles.push(initial_pdg.as_str().parse::<i32>().unwrap());
                    }
                    for final_pdg in sp_spec.next().unwrap().into_inner() {
                        final_particles.push(final_pdg.as_str().parse::<i32>().unwrap());
                    }
                    let sp_id: i32 = inner_rules.next().unwrap().as_str().parse::<i32>().unwrap();
                    sp_table.insert((initial_particles, final_particles), sp_id);
                }
                Rule::EOI => (),
                _ => unreachable!(),
            }
        }
        return Ok(sp_table);
    }
}

#[cfg(test)]
mod tests {
    use super::{OLCParser};
    #[test]
    fn parse_test() {
        let test_string = String::from(r"# BLHA order written by WHIZARD 3.1.4.1

# BLHA interface mode: OpenLoops
# process: VBF_REAL
# model: SM
InterfaceVersion         BLHA2      | Ok
CorrectionType           QCD      | OK
Extra AnswerFile         VBF_REAL.olc      | OK
IRregularisation         CDR      | OK
CouplingPower QCD        1     | OK
CouplingPower QED        4     | OK
ewscheme                 alphaMZ      | OK
extra use_cms            1      | OK
extra me_cache           0      | OK
extra IR_on              0      | OK
extra psp_tolerance      10e-7      | OK


# Process definitions


AmplitudeType            Tree      | OK
 -2  -2 ->  25  25  -2  -2  21 | 1    1

AmplitudeType            Tree      | OK
 -2   2 ->  25  25  -2   2  21 | 1    2

AmplitudeType            Tree      | OK
 -2   2 ->  25  25  -3   3  21 | 1    3

AmplitudeType            Tree      | OK
 -2   2 ->  25  25  -1   1  21 | 1    4

AmplitudeType            Tree      | OK
 -2   2 ->  25  25  -4   4  21 | 1    5

AmplitudeType            Tree      | OK
 -2  -3 ->  25  25  -2  -3  21 | 1    6

AmplitudeType            Tree      | OK
 -2  -3 ->  25  25  -1  -4  21 | 1    7

AmplitudeType            Tree      | OK
 -2   3 ->  25  25  -2   3  21 | 1    8

AmplitudeType            Tree      | OK
 -2  21 ->  25  25  -2  -2   2 | 1    9

AmplitudeType            Tree      | OK
 -2  21 ->  25  25  -2   2  -2 | 1   10

AmplitudeType            Tree      | OK
 -2  21 ->  25  25  -3   3  -2 | 1   11

AmplitudeType            Tree      | OK
 -2  21 ->  25  25  -2  -3   3 | 1   12

AmplitudeType            Tree      | OK
 -2  21 ->  25  25  -2   3  -3 | 1   13

AmplitudeType            Tree      | OK
 -2  21 ->  25  25  -1   1  -2 | 1   14

AmplitudeType            Tree      | OK
 -2  21 ->  25  25  -2  -1   1 | 1   15

AmplitudeType            Tree      | OK
 -2  21 ->  25  25  -2   1  -1 | 1   16

AmplitudeType            Tree      | OK
 -2  21 ->  25  25  -4   4  -2 | 1   17

AmplitudeType            Tree      | OK
 -2  21 ->  25  25  -2  -4   4 | 1   18

AmplitudeType            Tree      | OK
 -2  21 ->  25  25  -2   4  -4 | 1   19

AmplitudeType            Tree      | OK
 -2  21 ->  25  25  -1  -4   3 | 1   20

AmplitudeType            Tree      | OK
 -2  21 ->  25  25  -4   3  -1 | 1   21

AmplitudeType            Tree      | OK
 -2  21 ->  25  25  -1   3  -4 | 1   22

AmplitudeType            Tree      | OK
 -2  -1 ->  25  25  -2  -1  21 | 1   23

AmplitudeType            Tree      | OK
 -2   1 ->  25  25  -2   1  21 | 1   24

AmplitudeType            Tree      | OK
 -2   1 ->  25  25  -4   3  21 | 1   25

AmplitudeType            Tree      | OK
 -2  -4 ->  25  25  -2  -4  21 | 1   26

AmplitudeType            Tree      | OK
 -2   4 ->  25  25  -2   4  21 | 1   27

AmplitudeType            Tree      | OK
 -2   4 ->  25  25  -1   3  21 | 1   28

AmplitudeType            Tree      | OK
  2  -2 ->  25  25  -2   2  21 | 1   29

AmplitudeType            Tree      | OK
  2  -2 ->  25  25  -3   3  21 | 1   30");
        let sp_table = OLCParser::subprocess_table_from_string(&test_string).unwrap();
        assert_eq!(*sp_table.get(&(vec![-2, 21], vec![25, 25, -1, 3, -4])).unwrap(), 22);
    }
}