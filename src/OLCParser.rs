use std::path::PathBuf;
use pest::Parser;
use pest_derive::Parser;
use std::collections::HashMap;
use std::fs;
use color_eyre::eyre::WrapErr;
use eyre::eyre;
use pest::iterators::Pair;
use serde::{Deserialize, Serialize};

/// Amplitude types defined by the BLHA2 standard.
#[allow(non_camel_case_types)]
#[derive(Eq, PartialEq, Hash, Clone, Serialize, Deserialize, Debug)]
pub enum AmplitudeType {
    Tree,
    scTree,
    ccTree,
    scTree2,
    Loop,
    LoopInduced,
}

/// Struct to hold the relevant properties of a subprocess.
#[derive(Eq, PartialEq, Hash, Clone, Serialize, Deserialize)]
pub struct Subprocess {
    amplitude_type: AmplitudeType,
    incoming: Vec<i32>,
    outgoing: Vec<i32>
}

impl Subprocess {
    pub fn new(amplitude_type: AmplitudeType, incoming: Vec<i32>, outgoing: Vec<i32>) -> Subprocess {
        return Subprocess {
            amplitude_type,
            incoming,
            outgoing
        };
    }
    pub fn n_external_legs(&self) -> usize {
        return self.incoming.len() + self.outgoing.len();
    }

    pub fn n_in(&self) -> usize {
        return self.incoming.len();
    }

    pub fn n_out(&self) -> usize {
        return self.outgoing.len();
    }

    /// Return a process identifier string of the form `incoming pdg codes -> outgoing pdg codes`.
    pub fn to_string(&self) -> String {
        let mut key_string = String::new();
        for i in &self.incoming {
            key_string.push_str(&i.to_string());
            key_string.push(' ');
        }
        key_string.push_str("-> ");
        for f in &self.outgoing {
            key_string.push_str(&f.to_string());
            key_string.push(' ');
        }
        return key_string;
    }
}

#[derive(Parser)]
#[grammar = "olc.pest"]
/// Parser for a `BLHA2` contract file. Only the table of subprocesses is kept, the initialization
/// fields are discarded.
///
/// The grammar used to parse the contract file is derived from contract files generated by
/// GoSam and Openloops2.
pub struct OLCParser;

impl OLCParser {
    /// Same as [OLCParser::subprocess_table_from_string], but the content is read from `file`.
    pub fn subprocess_table_from_file(file: &PathBuf) -> eyre::Result<HashMap<Subprocess, i32>> {
        let file_content = fs::read_to_string(file)
            .wrap_err_with(|| format!("Failed to read contract file {:#?}", file))?;
        let parsed_file = OLCParser::parse(Rule::file, &file_content)?.next().unwrap();
        return Self::translate_rules(parsed_file);

    }
    /// Reads a `BLHA2` contract file from the `String` `content` and returns a hash map containing
    /// all subprocesses defined in the contract file. The key is a tuple of vectors
    /// `(Vec<i32>, Vec<i32>) containing a list of the incoming PDG codes in the first entry and a
    /// list of outgoing PDG codes in the second component. The value assigned to the key is the ID
    /// assigned to the subprocess by the OLP.
    ///
    /// # Example
    /// ```rust
    /// use BLHACompare::OLCParser::{AmplitudeType, OLCParser, Subprocess};
    /// let table = OLCParser::subprocess_table_from_string(&String::from(r"AmplitudeType Tree | OK
    /// -2 21 -> 25 25 -2 -3 3 | 1 16")).unwrap();
    /// let subprocess = Subprocess::new(AmplitudeType::Tree, vec![-2, 21], vec![25, 25, -2, -3, 3]);
    /// assert_eq!(*table.get(&subprocess).unwrap(), 16);
    /// ```
    pub fn subprocess_table_from_string(content: &String) -> eyre::Result<HashMap<Subprocess, i32>> {
        let parsed_string = OLCParser::parse(Rule::file, content)?.next().unwrap();
        return Self::translate_rules(parsed_string);
    }

    fn translate_rules(parsed_content: Pair<Rule>) -> eyre::Result<HashMap<Subprocess, i32>>{
        let mut sp_table = HashMap::<Subprocess, i32>::new();
        let mut current_amplitude_type = AmplitudeType::Loop;
        for sp_rule in parsed_content.into_inner() {
            match sp_rule.as_rule() {
                Rule::amplitude_type_specification => {
                    let amplitude_type = sp_rule.into_inner();
                    current_amplitude_type = match amplitude_type.as_str().to_lowercase().as_str() {
                        "tree" => AmplitudeType::Tree,
                        "sctree" => AmplitudeType::scTree,
                        "sctree2" => AmplitudeType::scTree2,
                        "cctree" => AmplitudeType::ccTree,
                        "loop" => AmplitudeType::Loop,
                        "loopinduced" => AmplitudeType::LoopInduced,
                        _ => return Err(eyre!("Encountered unknown amplitude type {}.", amplitude_type.as_str())),
                    }
                }
                Rule::subprocess => {
                    if current_amplitude_type != AmplitudeType::Tree && current_amplitude_type != AmplitudeType::Loop {
                        continue;
                    }
                    let mut inner_rules = sp_rule.into_inner();
                    let mut initial_particles = Vec::<i32>::new();
                    let mut final_particles = Vec::<i32>::new();
                    let mut sp_spec = inner_rules.next().unwrap().into_inner();
                    for initial_pdg in sp_spec.next().unwrap().into_inner() {
                        initial_particles.push(initial_pdg.as_str().parse::<i32>().unwrap());
                    }
                    for final_pdg in sp_spec.next().unwrap().into_inner() {
                        final_particles.push(final_pdg.as_str().parse::<i32>().unwrap());
                    }
                    let sp_id: i32 = inner_rules.next().unwrap().as_str().parse::<i32>().unwrap();
                    sp_table.insert(Subprocess::new(current_amplitude_type.clone(), initial_particles, final_particles), sp_id);
                }
                Rule::EOI => (),
                _ => unreachable!(),
            }
        }
        return Ok(sp_table);
    }
}

#[cfg(test)]
mod tests {
    use super::{AmplitudeType, OLCParser, Subprocess};
    #[test]
    fn parse_test() {
        let test_string = String::from(r"# BLHA order written by WHIZARD 3.1.4.1

# BLHA interface mode: OpenLoops
# process: VBF_REAL
# model: SM
InterfaceVersion         BLHA2      | Ok
CorrectionType           QCD      | OK
Extra AnswerFile         VBF_REAL.olc      | OK
IRregularisation         CDR      | OK
CouplingPower QCD        1     | OK
CouplingPower QED        4     | OK
ewscheme                 alphaMZ      | OK
extra use_cms            1      | OK
extra me_cache           0      | OK
extra IR_on              0      | OK
extra psp_tolerance      10e-7      | OK


# Process definitions


AmplitudeType            Tree      | OK
 -2  -2 ->  25  25  -2  -2  21 | 1    1

AmplitudeType            Tree      | OK
 -2   2 ->  25  25  -2   2  21 | 1    2

AmplitudeType            Tree      | OK
 -2   2 ->  25  25  -3   3  21 | 1    3

AmplitudeType            Tree      | OK
 -2   2 ->  25  25  -1   1  21 | 1    4

AmplitudeType            Tree      | OK
 -2   2 ->  25  25  -4   4  21 | 1    5

AmplitudeType            Tree      | OK
 -2  -3 ->  25  25  -2  -3  21 | 1    6

AmplitudeType            Tree      | OK
 -2  -3 ->  25  25  -1  -4  21 | 1    7

AmplitudeType            Tree      | OK
 -2   3 ->  25  25  -2   3  21 | 1    8

AmplitudeType            Tree      | OK
 -2  21 ->  25  25  -2  -2   2 | 1    9

AmplitudeType            Tree      | OK
 -2  21 ->  25  25  -2   2  -2 | 1   10

AmplitudeType            Tree      | OK
 -2  21 ->  25  25  -3   3  -2 | 1   11

AmplitudeType            Tree      | OK
 -2  21 ->  25  25  -2  -3   3 | 1   12

AmplitudeType            Tree      | OK
 -2  21 ->  25  25  -2   3  -3 | 1   13

AmplitudeType            Tree      | OK
 -2  21 ->  25  25  -1   1  -2 | 1   14

AmplitudeType            Tree      | OK
 -2  21 ->  25  25  -2  -1   1 | 1   15

AmplitudeType            Tree      | OK
 -2  21 ->  25  25  -2   1  -1 | 1   16

AmplitudeType            Tree      | OK
 -2  21 ->  25  25  -4   4  -2 | 1   17

AmplitudeType            Tree      | OK
 -2  21 ->  25  25  -2  -4   4 | 1   18

AmplitudeType            Tree      | OK
 -2  21 ->  25  25  -2   4  -4 | 1   19

AmplitudeType            Tree      | OK
 -2  21 ->  25  25  -1  -4   3 | 1   20

AmplitudeType            Tree      | OK
 -2  21 ->  25  25  -4   3  -1 | 1   21

AmplitudeType            Tree      | OK
 -2  21 ->  25  25  -1   3  -4 | 1   22

AmplitudeType            Tree      | OK
 -2  -1 ->  25  25  -2  -1  21 | 1   23

AmplitudeType            Tree      | OK
 -2   1 ->  25  25  -2   1  21 | 1   24

AmplitudeType            Tree      | OK
 -2   1 ->  25  25  -4   3  21 | 1   25

AmplitudeType            Tree      | OK
 -2  -4 ->  25  25  -2  -4  21 | 1   26

AmplitudeType            Tree      | OK
 -2   4 ->  25  25  -2   4  21 | 1   27

AmplitudeType            Tree      | OK
 -2   4 ->  25  25  -1   3  21 | 1   28

AmplitudeType            Tree      | OK
  2  -2 ->  25  25  -2   2  21 | 1   29

AmplitudeType            Tree      | OK
  2  -2 ->  25  25  -3   3  21 | 1   30");
        let sp_table = OLCParser::subprocess_table_from_string(&test_string).unwrap();
        let sp = Subprocess::new(AmplitudeType::Tree, vec![-2, 21], vec![25, 25, -1, 3, -4]);
        assert_eq!(*sp_table.get(&sp).unwrap(), 22);
    }
}